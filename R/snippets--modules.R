# ======================================================================== ~~~~
# Snippet Modules -------------------------------------------------------- ====
# ======================================================================== ~~~~

#' @name snippet-modules
#' @title Manage Snippet Modules
#' @description
#' Install, remove and manage modular snippet collections.
#' Modules follow the naming convention `{module}-{type}.snippets`
#' (e.g., `dplyr-r.snippets`, `ggplot2-r.snippets`).
#'
#' @concept snippet modules

# Helper Functions --------------------------------------------------------

#' Get path to snippet modules directory
#'
#' @return Path to the snippet modules directory
#' @noRd
get_snippet_modules_dir <- function() {
  # Use safe version that works outside RStudio
  base_dir <- tryCatch({
    get_path_rstudio_snippets_dir()
  }, error = function(e) {
    # Fallback for testing outside RStudio
    fs::path_expand_r("~/.R/snippets/")
  })
  
  modules_dir <- fs::path(base_dir, "snippet-modules")
  if (!fs::dir_exists(modules_dir)) {
    fs::dir_create(modules_dir, recurse = TRUE)
  }
  modules_dir
}

#' Get path to module registry file
#'
#' @return Path to the module registry JSON file
#' @noRd
get_module_registry_path <- function() {
  # Use safe version that works outside RStudio
  base_dir <- tryCatch({
    get_path_rstudio_snippets_dir()
  }, error = function(e) {
    # Fallback for testing outside RStudio
    fs::path_expand_r("~/.R/snippets/")
  })
  
  fs::path(base_dir, "module_registry.json")
}

#' Create module filename from module name and type
#'
#' @param module Module name (e.g., "dplyr")
#' @param type Snippet type (e.g., "r")
#' @return Filename following convention `{module}-{type}.snippets`
#' @noRd
make_module_filename <- function(module, type) {
  stringr::str_glue("{module}-{type}.snippets")
}

#' Parse module filename to extract module name and type
#'
#' @param filename Module filename
#' @return Named list with 'module' and 'type' components
#' @noRd
parse_module_filename <- function(filename) {
  # Remove .snippets extension
  basename <- stringr::str_remove(filename, "\\.snippets$")
  
  # Split on last dash to get module and type
  parts <- stringr::str_split(basename, "-", n = Inf)[[1]]
  
  if (length(parts) < 2) {
    usethis::ui_stop("Invalid module filename format: {filename}")
  }
  
  # Last part is type, everything before is module name
  type <- parts[length(parts)]
  module <- paste(parts[-length(parts)], collapse = "-")
  
  list(module = module, type = type)
}

#' Read module registry
#'
#' @return List containing module registry data
#' @noRd
read_module_registry <- function() {
  registry_path <- get_module_registry_path()
  
  if (!fs::file_exists(registry_path)) {
    return(list(modules = list(), last_updated = Sys.time()))
  }
  
  tryCatch({
    jsonlite::fromJSON(registry_path, simplifyVector = FALSE)
  }, error = function(e) {
    usethis::ui_warn("Module registry corrupted, creating new one")
    list(modules = list(), last_updated = Sys.time())
  })
}

#' Write module registry
#'
#' @param registry Registry data to write
#' @noRd
write_module_registry <- function(registry) {
  registry$last_updated <- Sys.time()
  registry_path <- get_module_registry_path()
  
  # Ensure directory exists
  fs::dir_create(fs::path_dir(registry_path), recurse = TRUE)
  
  jsonlite::write_json(registry, registry_path, pretty = TRUE, auto_unbox = TRUE)
}

#' Compose snippets from multiple modules into a single file
#'
#' @param modules Character vector of module names
#' @param type Snippet type (e.g., "r")
#' @param output_path Path where to write the composed file
#' @return Logical indicating success
#' @noRd
compose_snippet_modules <- function(modules, type, output_path) {
  modules_dir <- get_snippet_modules_dir()
  composed_content <- character(0)
  
  # Header
  composed_content <- c(
    composed_content,
    "# This file was automatically generated by the snippets package",
    paste("#", Sys.time()),
    paste("# Modules:", paste(modules, collapse = ", ")),
    ""
  )
  
  for (module in modules) {
    module_filename <- make_module_filename(module, type)
    module_path <- fs::path(modules_dir, module_filename)
    
    if (!fs::file_exists(module_path)) {
      usethis::ui_warn("Module file not found: {module_filename}")
      next
    }
    
    # Read module content
    module_content <- readr::read_lines(module_path)
    
    # Add module header
    composed_content <- c(
      composed_content,
      paste("# === MODULE:", paste(module, type, sep = "-"), "==="),
      module_content,
      paste("# === END MODULE:", paste(module, type, sep = "-"), "==="),
      ""
    )
  }
  
  # Write composed file
  readr::write_lines(composed_content, output_path)
  
  TRUE
}

# Main Functions ----------------------------------------------------------

#' List available snippet modules
#'
#' @param type Snippet type to filter by (e.g., "r", "markdown"). 
#'   Use "all" to show all types.
#' @param source Source to filter by ("package", "local", "all")
#' @param installed_only Show only installed modules
#'
#' @return Data frame with module information
#' @export
#' @concept snippet modules
#'
#' @examples
#' \dontrun{\donttest{
#' # List all available R modules
#' list_snippet_modules(type = "r")
#' 
#' # List all installed modules
#' list_snippet_modules(installed_only = TRUE)
#' 
#' # List modules from package
#' list_snippet_modules(source = "package")
#' }}
list_snippet_modules <- function(type = "all", source = "all", installed_only = FALSE) {
  modules_info <- data.frame(
    module = character(0),
    type = character(0),
    source = character(0),
    installed = logical(0),
    path = character(0),
    stringsAsFactors = FALSE
  )
  
  # Get modules from package
  if (source %in% c("all", "package")) {
    pkg_snippets_dir <- get_path_snippets_dir_of_pkg("snippets")
    if (pkg_snippets_dir != "") {
      # Look for files with module naming pattern: *-*.snippets
      pkg_files <- fs::dir_ls(pkg_snippets_dir, regexp = ".*-.*\\.snippets$")
      
      for (file in pkg_files) {
        filename <- fs::path_file(file)
        
        # Skip files that don't follow module format (e.g., just "r.snippets")
        if (!stringr::str_detect(filename, "^.+-.+\\.snippets$")) {
          next
        }
        
        tryCatch({
          parsed <- parse_module_filename(filename)
          if (type == "all" || parsed$type == type) {
            modules_info <- rbind(modules_info, data.frame(
              module = parsed$module,
              type = parsed$type,
              source = "package",
              installed = FALSE,  # Will be updated below
              path = file,
              stringsAsFactors = FALSE
            ))
          }
        }, error = function(e) {
          # Skip files that can't be parsed as modules
        })
      }
    }
  }
  
  # Get local modules
  if (source %in% c("all", "local")) {
    modules_dir <- get_snippet_modules_dir()
    if (fs::dir_exists(modules_dir)) {
      local_files <- fs::dir_ls(modules_dir, regexp = ".*-.*\\.snippets$")
      
      for (file in local_files) {
        filename <- fs::path_file(file)
        
        # Skip files that don't follow module format
        if (!stringr::str_detect(filename, "^.+-.+\\.snippets$")) {
          next
        }
        
        tryCatch({
          parsed <- parse_module_filename(filename)
          if (type == "all" || parsed$type == type) {
            modules_info <- rbind(modules_info, data.frame(
              module = parsed$module,
              type = parsed$type,
              source = "local",
              installed = FALSE,  # Will be updated below
              path = file,
              stringsAsFactors = FALSE
            ))
          }
        }, error = function(e) {
          # Skip files that can't be parsed as modules
        })
      }
    }
  }
  
  # Check installation status
  registry <- read_module_registry()
  for (i in seq_len(nrow(modules_info))) {
    module_key <- paste(modules_info$module[i], modules_info$type[i], sep = "-")
    modules_info$installed[i] <- module_key %in% names(registry$modules)
  }
  
  if (installed_only) {
    modules_info <- modules_info[modules_info$installed, ]
  }
  
  modules_info
}

#' Show currently active (installed) modules
#'
#' @param type Snippet type to show (e.g., "r", "markdown"). 
#'   Use "all" to show all types.
#'
#' @return Data frame with active module information
#' @export
#' @concept snippet modules
#'
#' @examples
#' \dontrun{\donttest{
#' # Show active R modules
#' show_active_modules(type = "r")
#' 
#' # Show all active modules
#' show_active_modules(type = "all")
#' }}
show_active_modules <- function(type = "all") {
  registry <- read_module_registry()
  
  if (length(registry$modules) == 0) {
    usethis::ui_info("No modules are currently installed.")
    return(invisible(data.frame()))
  }
  
  active_info <- data.frame(
    module = character(0),
    type = character(0),
    source = character(0),
    installed_date = character(0),
    stringsAsFactors = FALSE
  )
  
  for (module_key in names(registry$modules)) {
    module_data <- registry$modules[[module_key]]
    parsed <- parse_module_filename(paste0(module_key, ".snippets"))
    
    if (type == "all" || parsed$type == type) {
      active_info <- rbind(active_info, data.frame(
        module = parsed$module,
        type = parsed$type,
        source = if(is.null(module_data$source)) "unknown" else module_data$source,
        installed_date = if(is.null(module_data$installed_date)) "unknown" else module_data$installed_date,
        stringsAsFactors = FALSE
      ))
    }
  }
  
  if (nrow(active_info) > 0) {
    usethis::ui_info("Active modules:")
    print(active_info)
  } else {
    usethis::ui_info("No modules of type '{type}' are installed.")
  }
  
  invisible(active_info)
}